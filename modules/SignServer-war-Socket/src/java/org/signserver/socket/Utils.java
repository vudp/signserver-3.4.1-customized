package org.signserver.socket;

public class Utils {
	public static final byte[] S_USERNAME = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x55, 0x73, 0x65, 0x72, 0x4E, 0x61, 0x6D, 0x65, 0x3E};
	public static final byte[] E_USERNAME = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x55, 0x73, 0x65, 0x72, 0x4E, 0x61, 0x6D, 0x65, 0x3E};
	
	public static final byte[] S_PASSWORD = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 0x3E};
	public static final byte[] E_PASSWORD = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x50, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64, 0x3E};
	
	public static final byte[] S_SIGNATURE = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x3E};
	public static final byte[] E_SIGNATURE = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x3E};
	
	public static final byte[] S_TIMESTAMP = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x3E};
	public static final byte[] E_TIMESTAMP = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x54, 0x69, 0x6D, 0x65, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x3E};
	
	public static final byte[] S_PKCS1SIGNATURE = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x50, 0x6B, 0x63, 0x73, 0x31, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x3E};
	public static final byte[] E_PKCS1SIGNATURE = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x50, 0x6B, 0x63, 0x73, 0x31, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x74, 0x75, 0x72, 0x65, 0x3E};
	
	public static final byte[] S_XMLDATA = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x58, 0x6D, 0x6C, 0x44, 0x61, 0x74, 0x61, 0x3E};
	public static final byte[] E_XMLDATA = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x58, 0x6D, 0x6C, 0x44, 0x61, 0x74, 0x61, 0x3E};
	
	public static final byte[] S_FILEDATA = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x46, 0x69, 0x6C, 0x65, 0x44, 0x61, 0x74, 0x61, 0x3E};
	public static final byte[] E_FILEDATA = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x46, 0x69, 0x6C, 0x65, 0x44, 0x61, 0x74, 0x61, 0x3E};
	
	public static final byte[] S_CREDENTIALDATA = {0x3C, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x6C, 0x44, 0x61, 0x74, 0x61, 0x3E};
	public static final byte[] E_CREDENTIALDATA = {0x3C, 0x2F, 0x63, 0x61, 0x67, 0x33, 0x36, 0x30, 0x3A, 0x43, 0x72, 0x65, 0x64, 0x65, 0x6E, 0x74, 0x69, 0x61, 0x6C, 0x44, 0x61, 0x74, 0x61, 0x3E};
	
	
	public static byte[] getBytesValue(byte[] src, byte[] pattern1, byte[] pattern2) {
		int index_start = indexOf(src, pattern1);
		int index_end = indexOf(src, pattern2);
		int length;
		byte[] res = null;
		if(index_start != -1) {
			index_start += pattern1.length;
			length = index_end - index_start;
			res = new byte[length];
			System.arraycopy(src, index_start, res, 0, length);
		}
		return res;
	}
	
	
    /**
     * Search the data byte array for the first occurrence 
     * of the byte array pattern.
     */
    public static int indexOf(byte[] data, byte[] pattern) {
        int[] failure = computeFailure(pattern);

        int j = 0;

        for (int i = 0; i < data.length; i++) {
            while (j > 0 && pattern[j] != data[i]) {
                j = failure[j - 1];
            }
            if (pattern[j] == data[i]) { 
                j++; 
            }
            if (j == pattern.length) {
                return i - pattern.length + 1;
            }
        }
        return -1;
    }

    /**
     * Computes the failure function using a boot-strapping process,
     * where the pattern is matched against itself.
     */
    private static int[] computeFailure(byte[] pattern) {
        int[] failure = new int[pattern.length];

        int j = 0;
        for (int i = 1; i < pattern.length; i++) {
            while (j>0 && pattern[j] != pattern[i]) {
                j = failure[j - 1];
            }
            if (pattern[j] == pattern[i]) {
                j++;
            }
            failure[i] = j;
        }

        return failure;
    }
    
    public static int byteArrayToInt(byte[] b) {
        return b[3] & 0xFF
                | (b[2] & 0xFF) << 8
                | (b[1] & 0xFF) << 16
                | (b[0] & 0xFF) << 24;
    }

    public static byte[] intToByteArray(int a) {
        return new byte[]{
            (byte) ((a >> 24) & 0xFF),
            (byte) ((a >> 16) & 0xFF),
            (byte) ((a >> 8) & 0xFF),
            (byte) (a & 0xFF)
        };
    }
    
    public static String getIPAdress(String ipcomming) {
		int index = ipcomming.indexOf(":");
		return ipcomming.substring(1, index);
	}

      
}
